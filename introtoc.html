<!DOCTYPE html>
<html>
    <head>
        <title>Язык Си</title>
        <meta charset="utf-8">
        <style>
            @import url(http://fonts.googleapis.com/css?family=Philosopher:400,700&subset=latin,cyrillic);
            @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic&subset=cyrillic-ext,latin);

            body { font-family: 'Ubuntu Condensed',sans-serif;}
            .title {
                background-image: url(./sir.png);
                background-repeat:no-repeat;
                background-size:cover;
                background-position: -1000% !important;
                text-align: right !important;
            }
            h1{
                font-family: 'Philosopher', cursive;
                font-weight: bold;
            }
            h2, h3 {
                font-family: 'Philosopher',sans-serif;
                font-weight: normal;
            }
            h2 { color: #777 }
            h3 { margin: 0; }
            table,td,th {border: 1px solid #aaa; border-collapse: collapse;}
            td, th {padding: 5px;}
            .bigger {font-size: 100px;}
            .evenbigger {font-size: 130px;}
            .evenbiggerthanthat {font-size: 150px;}
            .biggest {font-size: 165px;}
            .biggest_memory{font-size:155px;}
            img.bump {margin-top: 30px;}
            .dark { background: #272822; color: #fff;}
            .esplosion {background-image: url(./giphy.gif);background-repeat:no-repeat;background-size:cover;}
            .thehorror {background-image: url(./giphy2.gif);background-repeat:no-repeat;background-size:cover;}
            .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Philosopher',sans-serif; }
            .white > * {color: #fff !important;}
        </style>
    </head>
    <body>
		<textarea id="source">

class: center, title

# Как выучить Си
*Введение для программиста высокого уровня*

---

# Необходимые знания

### 1. Знать как минимум 1 язык программирования
Предпочтительно два, потому что вы будете знать, как логически решить проблему, но выразить это двумя различными способами. *Не выбирайте Cи в качестве первого языка.*
### 2. Логическое мышление
Вы должны быть в состоянии разбивать задачи в простые шаги, которые компьютер может понять. Если вы не можете думать, как компьютер, вам будет сложно отлаживать программу.
### 3. Время
Си — это не тот язык, который вы быстро выучите и начнете что-то достойное писать безошибочно. Вы будете писать программы, которые не будут правильно работать. Пройдет какое-то время, прежде чем вы сможете быстро определять проблемы в коде.

---
# Почему вам надо учить Си
<small>Си вам нужен только для проектов, в которых требуется низкоуровневый доступ к системе или требуется очень быстрое выполнение каких-либо операций.</small>
### 1. Продвинутая разработка игр (в сочетании с хорошим фреймворком для этого)
Для *улучшений* производительности ресурсоёмких 3D приложений. *<small>Вам необходимо иметь некие математические знания (линейная алгебра, мат. анализ и, возможно, физика) для этого.</small>*

### 2. Компиляторы
Можете почитать книжку про дизайн компиляторов.

### 3. Встроенные приложения
Когда вы пытаетесь выжать производительность на максимум, используя минимум ресурсов, вы вряд ли захотите прошивать микроконтроллер Ruby интерпретатором чтобы запустить скрипт.

---
# Почему вам надо учить Си
### 4. Операционные системы
ДА! LINUX!!! Или ваша собственная доморощенная ОС, если хотите.

### 5. LINUX
ДА! LINUX!!! Хакинг ядра, разработка утилит коммандной строки, писать замену Systemd и т.д.

<br/>
<br/>

Если вы хотите написать скрипт, считающий количество вхождений строки "Foo" в некотором текстовом файле, то вы ошиблись адресом.
---
class: center, middle, dark
# Если вы все еще уверены, что хотите узнать C, давайте по-быстрому пробежимся по синтаксису, чтобы вы знали, что тут вообще происходит.
---
class: center, middle, dark
# Это слайд-шоу поможет вам узнать и понять запутанную концепцию языка Си.
---
class: center, middle, dark

# За кулисами

---
class: center, middle, dark
### Интрепретация
vs
### Компиляция
---

# Пример
### Ruby
Как только вы закончите писать код, вы можете запустить его. Интерпретатор Ruby будет выполнять код шаг за шагом:
```bash
ruby test.rb
#=> Да! Рабочий код!
```
### C
Си требует, чтобы вы сначала **компилировали** свой исходный код в бинарный исполняемый файл.
```bash
# Скомпилировать код моей программы в новый исполняемый файл с названием 'test'
cc -o test test.c

# Запустить мою программу
./test
```
---

## Плюсы компилирования
- Просто распространять
- Быстро работает
- Автоматическая обфускация (они не смогут прочитать твой код!)
- Компилятор связывает код в одно целое

## Минусы
- Должно быть скомпилировано под каждую архитектуру(ARM, x86, x86-64, etc)
- Сложнее отлаживать код

---
class: center, middle, dark
### Динамическое типизирование
vs
### Статическое типизирование
---
# Example
### Ruby
Переменные могут быть чем угодно!
```ruby
my_var = 4 # Посмотрите на этот integer
my_var = 2.0 # Теперь он float
my_var = [1,2,3] # Оооо, массив!
my_var = 'a string of stuff' # СЛОВО! (так же известное как string)
```
### C
Единажды определив тип переменной для вашей переменной, вы не сможете его изменить в дальнейшем.
```c
int my_var = 3; // Это int!
my_var = "abc"; // ОШИБКА КОМПИЛЯТОРА! Вы уже сказали, что это — int!

/* вставить взрыв здесь */
```
---
class: center, middle, dark
### Безопасно
vs
### Небезопасно
---
# Пример
### Ruby
Интерпретатор Ruby усиливает здравомыслие в коде.
```ruby
a = ['a', 'b', 'c']
a[2]
# => c
a[5] # ну уж нет!
# => Ошибка: идиот-программист пытается получить доступ к элементу,
#    которого не существует!
```
### C
В Си, вы можете делать все, что вы, черт побери, хотите.
```c
char a[] = {'a', 'b', 'c'};
a[2]
//=> 'c'
a[5] // Да без вопросов! Держи немного мусора!
//=> ajskdi&E3j ... Ошбика: segfault
```
---
class: center, middle, dark
### Автоматическое распределение памяти и сборка мусора
vs
### Ручное распределение памяти и сборка мусора
---
# Example
### Ruby
```ruby
def my_memory_function
		cats = get_all_teh_images_on_imgur
		process_images(cats) # Юху, она занимает МНОГО памяти
end # УДАЛИТЬ КИСОК
# Переменная cats больше не существует! Память была от нее очищена!
```

### C
```c
void my_memory_function() {
		// Выделяем память под набор картинок с кисками
		images *cats = malloc(sizeof(cat_image) * NUMBER_OF_CATS_ON_IMGUR);
		get_all_teh_images_on_imgur(cats); // теперь мы можем их скачать
		process_images(cats);
		// а киски то еще в памяти!
		free(cats); // не забудте это, а то эта память так
                    // и останется зарезервирована для этих картинок ;)

		// ооп, теперь они пропали
}
```
---
class: center, middle, dark
# Заметьте:

---
class: center, middle, dark
# ВЫ ДОЛЖНЫ

---
class: center, middle, dark
# .bigger[ВСЕГДА]

---
class: center, middle, dark
# .evenbigger[СЛЕДИТЬ]

---
class: center, middle, dark
# .evenbiggerthanthat[ЗА]

---
class: center, middle, dark, esplosion
# .biggest_memory[ПАМЯТЬЮ]
---
class: center, middle, dark
# Иначе произойдут BadThings<sup><small>TM</small></sup>
*Взрывы и плачущие щенки. Это плохо.*
---
class: center, middle, dark
# Вперед! К сложностям!
---
class: center, middle, dark, thehorror
#.biggest[Указатели!]
---
# Указатели
... как основа Си. Они дают вам великую силу (поэтому будте осторожны).

*Указатель — это переменная, содержащая адрес памяти (возможно, другой переменной).*

В Си, символ '`*`' обозначает переменную как указатель на любой тип данных обозначеный ранее.

```c
int *i_ptr;   // этот указатель может указывать на целое число
float *f_ptr; // этот указатель может указывать на число с плавающей точкой
int **ii_ptr; // этот указатель указывает на указатель на целое число
```

Символ '`&`' позволяет вам получить ячейку памяти переменной:
```c
int x = 3;
int *i_ptr = &x; // i_ptr — это указатель на ячейку памяти переменной 'x'
```
---
Память выглядит примерно так:

адрес        | значение
-------------|---------
`0x00`	     |
`0x01`	     |
`0x02`	     |
`0x03`	     |

И пермеменная — это просто именованый адрес ячейки памяти:

```c
int x = 3; // Компилятор выбирает ячейку памяти. Скажем, 0x01
```

адрес        | значение
-------------|---------
`0x00`	     |
`0x01`	     | `3`
`0x02`	     |
`0x03`	     |

<small><small>В реальной жизни вы не должны знать расположение переменных в памяти. Это просто для демонстрации.</small></small>
---
Если мы создадим указатель, указывающий на переменную `x`:
```c
int *i_ptr = &x; // итак, i_ptr должна содержать 0x01.
```
`i_ptr` — это **переменная**, и так же **располагается в памяти.** Пусть в `0x02`.

адрес        | значение
-------------|---------
`0x00`	     |
`0x01`	     | `3`
`0x02`	     | `0x01`
`0x03`	     |

Если мы решим создать указатель на указатель на целое число (`int **`) на `i_ptr`:
```c
int **ii_ptr = &i_ptr; // пусть валяется ii_ptr в 0x03
```
адрес        | значение
-------------|---------
`0x00`    	 |
`0x01`	     | `3`
`0x02`    	 | `0x01`
`0x03`	     | `0x02`
---
class: center, middle, dark
# Замечательно, теперь у нас есть указатель на указатель на целое число. Но как нам получить значение?
---
И тут вступает в игру оператор разыменовки '`*`'.

`*` разыменовывает (или следует по ссылкам) указатель в место, на которое он указывает:
```c
int y = *i_ptr;     // даёт нам значение, на которое указывает i_ptr
int z = **ii_ptr;   // даёт сначала следует на первый указатель,
                    // затем следует по второму указателю к значению.
```

Мне нравится думать, что указатель — это папка, а значение — это файлI like to think of a pointer as a directory and the value as a file.
```
─── ii_ptr
		└── i_ptr
				└── x
```
Then, '`*`' would move down a directory and '`&`' would move up a directory.
---
Wait, but what about multiple files! That would break the analogy!
```
─── ii_ptr
		└── i_ptr
				├── x
				└── y
```

Actually, this is how arrays are handled in C. A C array is a set of consecutive memory addresses. The first value is pointed to by a pointer.

```c
int a[] = {1, 2, 3}; // create an array
// a is just a pointer to the first element...
int first_val = *a; //... so dereferencing it will give us the first value.
int second_val = *(a + 1); // get the next memory address (a + 1),
													 // then follow (or step into) that memory address ('*')
int third_value = a[2]; // this is just syntactic sugar for *(a + 2)
```
---
class: center, middle, dark
# There's a limitation to C arrays.
---
class: center, middle, dark
# They aren't dynamic.
---
class: center, middle, dark
# You want to push a new element to the end of an array?
---
class: center, middle, dark
# Guess what, bucko?
---
class: center, middle, dark
# You have to *manually* allocate space for the new value
---
# `malloc` and `realloc`
*Manually allocating space in memory since 1972.*

`malloc` takes one argument: the number of bytes that need to be allocated.

`sizeof(int)` returns the number of bytes in an integer, which we multiply by the number of elements in the array.
```c
int num_of_elements = 3;
int *resize_arr = malloc(sizeof(int) * num_of_elements);
// ... put stuff in it ...
```
To make room for a new element:
```c
resize_arr = realloc(resize_arr, sizeof(int) * (num_of_elements + 1));
```
The first argument is the pointer to reallocate, the second is the new size of the pointer.

Don't forget to free it when you're done:
```c
free(resize_arr);
```
---
class: center, middle, dark
# And finally
---
class: center, middle, dark
# a concept that not difficult to understand
---
class: center, middle, dark
# but foundational
---
class: center, middle, dark
# C doesn't care about your data
---
# What does that mean?
C doesn't give a flying crap about your types. You want to cast your integer to a char? Go ahead:
```c
char letter = 'a';
int x = (int) a; // look. it's now an int
```

A pointer to an integer:
```c
int x = 3;
int *ptr = &x;
int y = (int) ptr;
```
Does it throw a warning because ints aren't the same size as pointers? Yes. Does it make sense? No. Does C still cast it? Yes.

Using an image library and want to cast an int to the first pixel? Go ahead:
```c
#include <img_lib.h>
int num = 30;
image *my_img = load_raw_image("./test.png");
my_img[0][0] = (pixel) num;
```
---
class: center, middle, dark
# And that covers the all difficult C concepts for beginners
---
# What you should remember
- C sees the world as a bunch of random bytes
- Pointers are just addresses. They are variables too.
- Arrays are collections of consecutive memory locations
---
# More resources for learning
- [The C Programming Language](http://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628), a book by the original creators of C. They know what they're talking about.
- An interactive [introduction to C](http://www.learn-c.org/)
- A collection of [good blog posts on C](http://www.cprogramming.com/tutorial/c-tutorial.html)
---
class: center, middle, dark
If you think of anything that could help improve this slideshow, .white[[let me know :)](http://twitter.com/theninjacharlie)]
---
class: center, middle, dark
created by .white[[@theninjacharlie](http://twitter.com/theninjacharlie)]
---
class: center, middle, dark
Переведено .white[[@mokeev1995](http://twitter.com/mokeev1995)] (.white[[mokeev1995.ru](http://mokeev1995.ru)])
</textarea>
        <script src="./remark-latest.min.js">
        </script>
        <script>
            var slideshow = remark.create();
        </script>
    </body>
</html>
